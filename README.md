
# SPUD (Structured Payload of Unintelligible Data)

SPUD is a custom binary file format designed for efficient storage and transmission of structured data. It uses schemas, type tags and field name interning to achieve a compact representation. This implementation is written in Rust.

## Features

* **Compact Binary Representation:** Uses binary encoding for data types.
* **Basic Data Types:** Supports `null`, `boolean`, various integer (`i8`-`i64`, `u8`-`u64`) and float (`f32`, `f64`) types, strings, and raw binary blobs.
* **Field Name Interning:** Assigns unique IDs to field names within a file to reduce redundancy and save space.
* **Versioning:** Files start with a version identifier (`SPUD_VERSION` environment variable at compile time) to ensure compatibility.
* **Simple Structure:** Consists of a version header, a field name map, the data payload, and an End-Of-File marker (`[0xDE, 0xAD, 0xBE, 0xEF]`).

## File Structure

A `.spud` file generally follows this structure:

1.  **Version String:** The `SPUD_VERSION` string (bytes).
2.  **Field Name Map:**
    * A sequence of `(length_byte, field_name_bytes, id_byte)`.
    * Ends with the `FieldNameListEnd` marker (`0x01`).
3.  **Data Payload:**
    * A sequence of `(FieldNameId_marker, field_id_byte, type_tag_byte, value_bytes)`.
    * String and BinaryBlob types include their length before the data.
4.  **EOF Marker:** The sequence `0xDE, 0xAD, 0xBE, 0xEF`.

## Usage

### Encoding (Creating a SPUD file)

```rust
// Example usage (assuming this code is within a function or main)
use spud::spud_builder::SpudBuilder;

let mut builder = SpudBuilder::new();

builder
    .add_string("name", "Example Object")
    .add_number("version", 1u8) //
    .add_bool("enabled", true) //
    .add_null("description") //
    .add_number("value", 123.45f64) //
    .add_binary_blob("raw_data", &[0x01, 0x02, 0x03, 0x04]); //

// Specify the output directory and filename (without extension)
builder.build_file("output_dir", "my_spud_data"); // Creates output_dir/my_spud_data.spud

println!("SPUD file created!");
```

### Decoding (Reading a SPUD file)

The current decoder primarily prints the contents to standard output.

```rust
// Example usage (assuming this code is within a function or main)
use spud::spud_decoder::SpudDecoder;

// Load from a file path
let mut decoder = SpudDecoder::new_from_path("output_dir/my_spud_data.spud"); //

// Or load from an existing byte vector
// let file_bytes: Vec<u8> = std::fs::read("output_dir/my_spud_data.spud").unwrap();
// let mut decoder = SpudDecoder::new(file_bytes); //

println!("Decoding SPUD file:");
decoder.decode(); // Prints decoded key-value pairs
println!("Decoding finished.");
```

## Roadmap / TODO

Here are some planned features and improvements:

* **[ ] Arrays and Objects:** Implement support for nested structures using the defined `ArrayStart`, `ArrayEnd`, `ObjectStart`, and `ObjectEnd` type tags. This will involve updating both the builder and decoder.
* **[ ] Improved Error Handling:** Replace `.unwrap()` and `panic!` calls in the decoder with proper `Result` types for robust error management. Define custom error types for different parsing issues.
* **[x] `serde` Integration:** Implement `serde::Serialize` for `SpudBuilder` and `serde::Deserialize` for `SpudDecoder` to allow seamless conversion between Rust structs and the SPUD format.
* **[ ] Documentation:** Generate API documentation using `cargo doc`.
* **[ ] More Types:** Support for timestamps, decimals, or other common data types if needed.

## Contributing

Contributions are welcome! Please open an issue to discuss changes or submit a pull request.

#### README.md partially generated by Gemini